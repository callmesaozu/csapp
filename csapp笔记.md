### 逻辑运算

- `a&&5/a`,避免被0除
- `p&&*p++`避免间接引用空指针

### 位移运算

```C
int x = 0x81462146;	//x = 0x81462146 = -2126110394
int m = x << k;
//m = 0x14621460
int n = x >> k;
//n = f8146214, x >> 4 = 0xf8146214 = -132881900
```

- `x<<j<<k`等价于`(x<<j)<<k`
- 逻辑右移：左端补k个0
- 算术右移：左端补k个最高有效位值
- 对于无符号数，必定是逻辑右移，对于有符号数，两种都有可能, C语言没有明确定义，但java有
- 几乎所有的编译器/机器组合都对有符号数使用算数右移
- 位移指令只考虑低$log_{2}w$位(w为数据类型的位数)，位移量是通过`k mod w`计算出来的,但事实上C语言并没有保证这种行为,所以位移数量要小于字长
	```C
	//32位机，理论上
	int lval = 0xFEDCBA98 << 32;
	int aval = 0xFEDCBA98 >> 36;
	unsigned uval = 0xFEDCBA98 >> 40;
	lval = 0xFEDCBA98;	//左移0位
	aval = 0xFFEDCBA9;	//右移4位
	uval = 0x00FEDCBA;	//右移8位
	//实际上
	int x = 0x81462146 = -2126110394;
	x << 32 = 0x81462146 = -2126110394;
	x >> 32 = 0x81462146 = -2126110394;
	```

- C语言中的位移优先级比加法和减法要低， `1<<2+3<<4`等价于`1<<(2+3)<<4`(512),所以混合运算的时候必须加括号

## 整数表示

### 整数数据类型

```C
sizeof(char) = 1
sizeof(int) = 4
sizeof(unsigned short) = 2
sizeof(long) = 8
sizeof(long long) = 8
```

- C、C++都支持有符号和无符号数，java只支持有符号数

### 无符号数编码

$$B2U_{w}(\vec x) \doteq \sum_{i = 0}^{w - 1}x_{i}2^{i}$$

### 补码编码

补码(two's-complement)是表示有符号数的常见形式

$$B2T_{w}(\vec x) \doteq -x_{w - 1}2^{w-1} + \sum_{i = 0}^{w - 2}x_{i}2^{i}$$

- C语言标准并不要求使用补码形式表示有符号数，但几乎所有的机器都使用补码
- `<limits.h>`定义了一组限定数值范围的常量
- `intN_t`、`uintN_t`用以限定位数(ISO C99 `<stdint.h>`)
- java明确规定用补码

- 反码（ones' complement）

	$$B2O_{w}(\vec x) \doteq -x_{w - 1}(2^{w-1} - 1) + \sum_{i = 0}^{w - 2}x_{i}2^{i}$$

- 原码（Sign-Magnitude）， 最高有效位是符号位
	$$B2S_{w}(\vec x) \doteq (-1)^{x_{w - 1}}（\sum_{i = 0}^{w - 2}x_{i}2^{i}）$$
    
### 强制类型转换

- 位值不变，而改变位的解释

```C
short int v = -12345;
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", v, uv);	//v = -12345, uv = 53191
```

- `C/C++`默认是有符号的，如果要使用无符号数字，需要在数字后加`u`或者`U`
`unsigned u = 4294967295u;`

- 当两种类型的变量赋值时，自动发生强制类型转换
- `printf("u = 0x%x = %u = %d\n", u, u, u);`, 十六进制数，无符号十进制数，有符号十进制数
- 如果两个数的运算，一个有符号，一个无符号，C语言会隐式地将有符号数转化为无符号数，并假设两个数非负，在`>`、`<`运算时要小心

### 扩展一个数字的位表示

- 零扩展（zero extention）：无符号数转换为一个更大的数，只需在表示的开头添加0
- 符号扩展（sign extention）：将补码数字转换为一个更大的数据类型，在表示中添加最高有效位的副本
- 补码的转换顺序会对结果有影响，c语言要求`(unsigned) sx`等价于`（unsigned）（int）sx`，而不是`(unsigned)(unsigned short) sx`，（`short sx`）

### 截断数字

- 大类型数字转换成小类型数字，直接抛弃高位
- 尽量不要使用无符号数
- `size_t` = `unsigned int`

## 整数运算

### 加法
- 无符号加法等价于计算和模上$2^w$
- 无符号加法的和为$s$，如果发生了溢出，则必然有$s = x + (y - 2^w) < x$,否则有$x + y \geqslant x$
- 补码加法
	- 负溢出： $x + y < -2^{w - 1} $
	- 正溢出： $x + y \geqslant 2^{w - 1} $
	- 当x和y都为负数，且$x + _{w}^{t}y \geqslant 0$, 负溢出
	- 当x和y都为正数，且$x + _{w}^{t}y < 0$, 正溢出
	
### 补码的非

$-2^{w-1} \leqslant x < 2^{w-1}$中的每个数字都有$+_w^t$下的加法逆元，对于$x = -2^{w-1} $,本身就是自己的加法逆元

非运算（negation operation）$-_w^t$:

$$
\begin{eqnarray}
-_w^tx =
\begin{cases}
-2^{w-1},       & x = -2^{w-1} \\
-x   & x > -2^{w-1}
\end{cases}
\end{eqnarray}
$$

补码的非运算就是无符号数的非运算`+1`，也即求补运算（`～x`）+1

或者$x = [x_{w-1}, x_{w-2},\cdots, x_{k+1},1, 0, \cdots,0]$，非运算可取$x = [\thicksim x_{w-1}, \thicksim x_{w-2},\cdots, \thicksim x_{k+1},1, 0, \cdots,0]$

### 无符号乘法

- 要完整表示乘法结果，无符号乘法和补码乘法都需要$2w$位

$$x*_w^uy = (x\cdot y)\quad mod \quad 2^w$$

即取低$w$位数值

### 补码乘法

补码的乘法同样也是截断，只不过是先算数扩展到2w位，然后相乘，取低w位的值
补码相乘的低w位和无符号乘法的低w位值是一样的，但是2w位值是不一样的
判断两个数相乘是否不会溢出：
```C
int tmult_ok(int x, int y)
{
	int p = x * y;
    return !x || p/x == y;
}
```

### 乘以常数

乘法指令相当慢，需要10个或更多时钟周期，而其他整数运算（加减、位级运算和移位）只需一个时钟周期，编译器会做出优化，因此，尽量使用变量乘以常数，而非变量乘以变量

假如乘以一个整数y：000(11...1)000, 第m位（低）到第n位（高）都是1，则可使用如下优化：
- 形式A：`(x<<n) + (x<<n-1) + ... + (x<<m)`
- 形式B：`(x<<n+1) - (x<<m)`
- 如果y的n位最高位， 则形式B为：`- (x<<m)`

### 除以2的幂

- 整数的除法要比乘法更慢，大约需要30个或更多的时钟周期
- 无符号数除以2的幂可以使用逻辑右移实现，补码则用算数位移实现，但对于除数不是2的幂的情况，不能用位移。
- 如果除不尽，位移的结果总是向下取整，这在补码为非负数时是正确的，但在负数时错误
- 因此需要修正，对于整数x和任意y>0, 有$\lceil x/y \rceil = \lfloor (x+y-1)/y \rfloor$,写成程序为`(x<0 ? (x + (1<<k) -1) : x) >> k`

### 整数运算总结

`unsigned`类型在书写整数常数和调用库函数时经常出现

## 浮点数

IEEE浮点标准用$V = (-1)^s \times M \times 2^E$表示一个数

- 符号s决定这个数是负数（s=1）还是正数（s=0），对于数值0的符号位解释作为特殊情况处理
- 尾数M是一个二进制小数，范围是$1 \thicksim 2- \varepsilon $或者是$0 \thicksim 1- \varepsilon $
- 阶码E的作用是对浮点数加权，权重是$2^E$

将浮点数的位表示划分为三个字段

- 一个单独的符号位s直接编码符号s
- k位的阶码字段$exp = e_{k-1} \cdots e_{1}e_{0}$编码阶码E
- n位的小数字段$frac=f_{n-1} \cdots f_{1}f_{0}$编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0

单精度浮点格式（C语言中的float）中s、exp、和frac字段分别为1位、$k = 8$位和$n = 23$位
双精度浮点格式（C语言中的double）中s、exp、和frac字段分别为1位、$k = 11$位和$n = 52$位

下面分类介绍（e=exp字段的无符号十六进制值， f=frac字段的无符号十六进制值, $Bias = 2^{k-1} -1$）

1. 规格化的： $e \neq 0 \&e \neq 255 $, $f$任意， $E = e - Bias$, $M = 1 + f$
2. 非规格化的： $e = 0$, $f$任意， $E = 1 - Bias$, $M = f$
3. 无穷大：  $e = 0xFF \cdots F$, $f = 0$
4. NaN(not a number)：  $e = 0xFF \cdots F$, $f \neq  0$, $\sqrt {-1}$或者$\infty -\infty$时会出现这种情况

### 舍入（rounding）

IEEE浮点标准定义4种舍入方式：
向偶数舍入（round-to-even），最接近的值舍入（round-to-nearest），默认舍入方式， 选择最接近的舍入数字，而当数字位于中间时，将数字向上或者向下舍入，使得结果的最低有效数字是偶数

| 方式       | 1.40 | 1.60 | 1.50 | 2.50 | -1.50 |
|-----------|------|------|------|------|-------|
| 向偶数舍入  |  1   | 2    | 2    |	2    |	-2   |
| 向零舍入   |	1    | 1    |  1   |  2   |  -1   |
| 向下舍入   |  1   |  1    |  1   |  2   |  -2   |
| 向上舍入   |   2  |  2    |  2   |  3   |  -1   |

向偶舍入舍入后的平均值没有偏差

### 浮点数运算

- IEEE将浮点数看成实数，运算$ \odot $定义在实数上，将产生$Round(x \odot y)$,对运算的精确结果进行舍入，对所有的$x, y$,$ \odot $可交换,但不可结合
- $1/-0 = - \infty$, $1/+0 = + \infty$

$(3.14 + 10^{10}) - 10^{10} = 0.0$, $3.14 + (10^{10} - 10^{10}) = 3.14$

大多数浮点加法都有逆元， 即$x +^f -x = 0$,但$+ \infty - \infty = NaN$, 任何$x$都有$NaN +^f x = NaN$

如果编译器对浮点数的计算进行优化，将会导致计算结果有偏差：
```C
x = a + b + c;
y = b + c + d;
//可能优化成：
t = b + c;
x = a + t;
y = t + d;
//这会与原始的值不同，在某些情况下(如爱国者导弹)会造成重要影响
```
- 浮点数加法满足单调性：如果$a \geqslant b$,则对于任何a、b、x除了NaN，都有$a + x \geqslant b + x$,但整数(无符号数和补码数)不具备
- 浮点数乘法$x *^f y = Round(x \times y)$,在乘法运算中封闭，可交换，乘法单位元为1.0，不具备可结合性,$(10^{20} * 10^{20}) * 10^{-20} = + \infty $, $10^{20} * (10^{20} * 10^{-20}) = 10^{20} $,也不具备对加法的分配性，如单精度情况下，$10^{20} * (10^{20} - 10^{20}) = 0.0 $， $10^{20} * 10^{20} - 10^{20} * 10^{20}) = NaN $
- 浮点数乘法满足单调性, 同样的，整型不满足
	$$a \geqslant b, c \geqslant 0 \Rightarrow a *^f c \geqslant b *^f c$$
    $$a \geqslant b, c \leqslant 0 \Rightarrow a *^f c \leqslant b *^f c$$
    只要$a \neq NaN$, 就有 $a *^f a \geqslant 0$
    

### C语言中的浮点数

- double, 64位
- float， 32位
- 不要求机器使用IEEE浮点
- ISO C99包含`long double`，大多数机器和编译器，这相当于`double`, 但Intel兼容机和GCC, 80位
- GCC： INFINITY， NAN

```C
# define _GNU_SOURCE 1
# include <math.h>
```

- int -> float,数字不会溢出， 但可能被舍入
- int， float -> double,数字不会溢出， 精确
- double -> float,可能溢出$+\infty$或者$-\infty$， 可能被舍入
- float， double -> int,可能溢出， 可能被向零舍入

Intel兼容机指定位模式$[10 \cdots 00]$为整数不确定模式，如果不能为该浮点数找到一个合理的整数近似值，就会得到这样一个值
如`(int)+1e10`得到`-21483648`

> Intel IA32处理器提供浮点数寄存器，80位，float 和 double数存入寄存器中时，都会转换成这种格式，取出时再转回来， 存入寄存器->取出->存入，可能会改变数值，新的Intel处理器能够对float和double提供直接的硬件支持，不会发生这种情况


